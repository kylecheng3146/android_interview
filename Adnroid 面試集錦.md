## 你知道Android Handler 也會造成 memory leak 嗎？

是的，Android Handler 也可能會引起內存洩漏問題。

Android 中的 Handler 類是用於在不同線程之間傳遞消息和執行代碼的機制。在使用 Handler 時，如果你將一個 Activity 或 Fragment 對象傳遞給 Handler，並在該對象被銷燬前沒有將 Handler 的引用清除，就可能會導致內存洩漏問題。這種情況下，由於 Handler 持有對 Activity 或 Fragment 的引用，Activity 或 Fragment 對象可能無法被垃圾回收，從而導致內存洩漏。

為了避免這種情況，你可以在 Activity 或 Fragment 的 onDestroy() 方法中清除 Handler 的引用，或者在 Activity 或 Fragment 對象不再需要使用 Handler 時調用 Handler 的 removeCallbacksAndMessages() 方法來清除 Handler 中的消息隊列。

另外，還有一種情況也可能會引起內存洩漏問題，即當使用匿名內部類實現 Handler.Callback 接口時，如果在該匿名內部類中持有對外部類的引用，就可能導致外部類對象無法被垃圾回收，從而引起內存洩漏問題。為了避免這種情況，你可以使用靜態內部類來實現 Handler.Callback 接口，或者使用弱引用來持有外部類的引用。

## Android 要自定義 View 該怎麼做？有什麼該注意的地方

在 Android 中，如果需要實現自定義的 View，一般需要繼承 View 或其子類（例如 TextView、ImageView 等），並重寫相關方法來實現自定義的行為和外觀。

下面是自定義 View 的基本步驟：

1. 繼承 View 或其子類，例如：

javaCopy code

`public class CustomView extends View {     // ... }`

2. 重寫構造方法，以便在代碼中創建 View 實例時進行初始化，例如：

scssCopy code

`public CustomView(Context context) {     super(context);     // ... }`

3. 重寫 onDraw() 方法，以便在 View 繪製時繪製自定義內容，例如：

typescriptCopy code

`@Override protected void onDraw(Canvas canvas) {     super.onDraw(canvas);     // 繪製自定義內容 }`

4. 在需要處理觸摸事件時，可以重寫 onTouchEvent() 方法，例如：

typescriptCopy code

`@Override public boolean onTouchEvent(MotionEvent event) {     // 處理觸摸事件     return super.onTouchEvent(event); }`

在實現自定義 View 時，需要注意以下幾點：

1. 自定義 View 的尺寸應該是明確的，否則可能會影響佈局的計算和其他 View 的擺放。可以在 onMeasure() 方法中計算 View 的寬度和高度。

2. 需要考慮 View 的狀態和狀態變化，例如：選中狀態、激活狀態、不可用狀態等。可以使用 StateListDrawable 和 ColorStateList 來定義狀態和狀態變化。

3. 在繪製自定義內容時，應該使用硬件加速和緩存來提高性能。可以使用 Canvas 的硬件加速方法和 Bitmap 緩存來優化繪製過程。

4. 在處理觸摸事件時，需要考慮事件的傳遞和處理順序，例如：是否要攔截事件、是否要將事件傳遞給父 View 等。可以使用 View 的 onTouchEvent() 方法和 ViewGroup 的 onInterceptTouchEvent() 方法來處理觸摸事件。

5. 在實現自定義 View 時，應該遵循 Android 的設計規範和最佳實踐，例如：使用適當的佈局參數、提供合適的默認值、支持多種屏幕尺寸和方向等。可以參考 Android 開發文檔和其他相關資料來學習這些規範和實踐。

## 在android中你是怎麼找、分析 memory leak?

在 Android 中，內存洩漏是一個常見的問題，可能會導致應用程序崩潰或變得緩慢。下面是我通常用來找和分析內存洩漏的方法：

1. 使用 Android Studio 的內存分析工具：Android Studio 提供了內存分析工具（Android Profiler），可以幫助你分析應用程序的內存使用情況。你可以使用 Android Profiler 來跟蹤應用程序中的對象分配情況、堆內存使用情況、內存洩漏等問題。你可以在開發者選項中啟用"立即啟動應用"，以便更容易地捕捉內存洩漏的情況。

2. 使用 LeakCanary 庫：LeakCanary 是一個開源庫，用於檢測內存洩漏問題。它能夠在應用程序中自動檢測和報告內存洩漏，並提供詳細的報告和分析工具。你可以將 LeakCanary 集成到你的應用程序中，並在應用程序中發現內存洩漏時收到通知。

3. 手動檢查代碼：手動檢查代碼是一種更耗時的方法，但也可以幫助你找到內存洩漏問題。你可以檢查應用程序中的對象引用，確保它們在不需要時被及時釋放。你可以使用 Android Studio 的內存監視器來檢查對象的生命週期和垃圾回收情況。

4. 使用 MAT 工具：MAT（Memory Analyzer Tool）是一個 Java 堆分析工具，也可以用於分析 Android 應用程序的內存使用情況。MAT 可以幫助你找到內存洩漏問題和不必要的對象引用，並提供詳細的分析報告。

總之，找和分析內存洩漏需要一定的技巧和經驗。你可以使用上述工具和方法來幫助你找到問題並進行解決。同時，應該在編寫代碼時養成良好的編碼習慣，及時釋放不再需要的對象引用，並在開發過程中注重性能優化和內存管理。

## Http 1.1 是怎麼保證長連接的？

HTTP 1.1 中，長連接是通過使用“Connection: keep-alive”頭部字段來實現的。當客戶端向服務器發送請求時，如果該請求包括“Connection: keep-alive”頭部字段，那麼該連接將保持打開狀態，並且服務器會在響應頭中也包含“Connection: keep-alive”字段，以確保服務器和客戶端都知道該連接是長連接。通過這種方式，客戶端和服務器可以在一個 TCP 連接上發送和接收多個 HTTP 請求和響應。

為了確保長連接不會被意外關閉，HTTP 1.1 中還引入了一個“Keep-Alive”超時機制。在“Keep-Alive”超時時間到期之前，如果客戶端沒有發送請求，則服務器會發送一個“Keep-Alive”響應，以保持連接的打開狀態。這個超時時間通常是在服務器配置中設置的，一般情況下默認為 5 秒。

需要注意的是，HTTP 1.1 的長連接並不是永久保持連接，它僅僅是在請求和響應之間保持 TCP 連接打開狀態。如果在一個長時間的空閒期之後，沒有新的請求或響應發送到服務器或客戶端，連接可能會被關閉。另外，雖然 HTTP 1.1 的長連接能夠提高性能，但是由於長時間的連接可能會佔用服務器資源，因此在一些情況下，如高併發環境下，可能需要對長連接的數量進行限制，以避免服務器資源被耗盡。

## android setMeasuredDimension 的作用是什麼？

在 Android 中，View 的測量過程是指計算 View 的大小和位置的過程。在測量過程中，View 會先測量其子 View 的大小和位置，然後根據子 View 的大小和位置來計算自身的大小和位置。setMeasuredDimension() 方法就是 View 在測量過程中用來設置自身大小的方法。

setMeasuredDimension() 方法接收兩個參數，分別表示 View 的寬度和高度。當調用 setMeasuredDimension() 方法後，View 的測量過程就會結束，並且系統會使用指定的寬度和高度來佈局和繪製該 View。

需要注意的是，setMeasuredDimension() 方法通常是在 View 的 onMeasure() 方法中調用的，而 onMeasure() 方法則是 View 測量過程中的一個重要回調方法。在 onMeasure() 方法中，View 可以通過設置 setMeasuredDimension() 方法的參數來指定自身的大小，以便系統在佈局和繪製該 View 時使用。

需要特別注意的是，setMeasuredDimension() 方法只會在測量過程中被調用，不應該在其他地方手動調用該方法。如果手動調用該方法，可能會破壞 View 的佈局和繪製。

## CAS - Compare and Swap 解釋一下？是什麼原理？相對於 lock 它有什麼優勢？它能解決什麼問題？

CAS，全稱為 Compare and Swap（比較並交換），是一種併發編程中的原子操作，用於實現多線程同步。

CAS 的基本原理是：在進行寫入操作之前，先比較當前值和期望值是否相等，如果相等，則進行寫入操作；否則不進行任何操作。這個過程是原子性的，即在這個過程中不會被其他線程中斷，保證了數據的一致性和線程安全性。

相對於 lock（鎖）機制，CAS 具有以下優點：

1. 沒有鎖定的問題。在併發操作中，使用鎖容易出現死鎖的問題。而 CAS 沒有鎖的問題，因為它只是對變量進行比較和修改，不需要鎖定整個對象。

2. 沒有線程掛起的問題。在使用鎖的時候，當一個線程獲取了鎖後，其他線程就會進入等待狀態，如果等待時間過長，就會影響程序的性能。而 CAS 沒有線程掛起的問題，因為在 CAS 操作中，如果比較失敗，線程可以立即返回，不需要等待。

3. 減少線程上下文切換的開銷。線程上下文切換會消耗大量的 CPU 時間，而在使用鎖的時候，線程會被掛起，等待鎖釋放，這就會導致線程上下文切換的開銷增加。而 CAS 操作是在用戶空間完成的，不會觸發內核態與用戶態之間的切換，因此可以減少線程上下文切換的開銷。

CAS 可以解決多線程併發訪問共享數據的問題，避免出現數據不一致的情況，提高程序的性能和效率。在 Java 中，CAS 操作通過 Atomic 類實現。但是需要注意，CAS 操作可能會出現ABA問題，即在比較操作之間，變量的值經過一次或多次變化，最終變回原值的情況。為了解決這個問題，可以使用版本號或時間戳等機制來保證數據的一致性。

## 解釋一下Android 事件分發機制？

Android 事件分發機制是指將用戶的觸摸事件（例如點擊、滑動等）分發給正確的 View 進行處理的過程。這個過程涉及到多個組件，包括 Activity、Window、ViewGroup 和 View 等。

在 Android 中，事件的分發遵循一定的規則。當用戶觸摸屏幕時，事件首先由 ActivityManagerService 將其發送到當前 Activity 對應的 Window。WindowManagerService 將事件分配給位於 Window 上的根 ViewGroup 處理。然後，根 ViewGroup 會將事件分配給其子 View 進行處理，這個過程是遞歸的，直到事件被處理或者沒有子 View 可以處理為止。

在事件分發過程中，每個 View 都有機會處理事件，可以通過 onTouchEvent() 方法來處理事件。如果事件在 View 中得到了處理，則事件不會繼續傳遞到其父 View 或 ViewGroup，否則事件會繼續傳遞，直到事件被處理或者到達了 View 樹的底部。

在事件分發過程中，還有兩個關鍵的方法：dispatchTouchEvent() 和 onInterceptTouchEvent()。dispatchTouchEvent() 是 View 和 ViewGroup 中用於分發事件的方法，用於將事件分發給子 View 進行處理或者自身進行處理。onInterceptTouchEvent() 是 ViewGroup 中用於攔截事件的方法，用於判斷是否需要攔截事件並將事件分發給自身進行處理，還是將事件繼續傳遞給子 View 進行處理。

需要注意的是，事件分發機制是整個 Android 應用程序的基礎，因此應該遵循一定的規則進行開發。例如，對於複雜的 View 層次結構，應該使用 onInterceptTouchEvent() 方法來避免事件被錯誤地分發。同時，對於需要支持多點觸控的應用程序，也需要在事件分發過程中進行適當的處理。

## android 列舉幾個性能優化步驟

以下是 Android 中常用的一些性能優化步驟：

1. 使用異步操作：異步操作可以避免在主線程上進行耗時操作，從而提高應用程序的響應速度。

2. 避免過度繪製：在繪製過程中避免繪製不必要的內容，以減少 CPU 和 GPU 的負擔。

3. 使用 ViewHolder 模式：在列表視圖中使用 ViewHolder 模式可以避免頻繁的視圖創建和銷燬操作，從而提高應用程序的響應速度。

4. 使用數據綁定框架：使用數據綁定框架可以避免手動更新視圖，從而提高應用程序的性能和可維護性。

5. 減少內存分配：減少對象的創建和銷燬可以減少內存分配和垃圾回收的開銷，從而提高應用程序的性能。

6. 使用圖片壓縮：對於需要加載大量圖片的應用程序，使用圖片壓縮技術可以減少圖片加載的時間和內存佔用。

7. 使用 Lint 工具：使用 Lint 工具可以幫助開發者檢測代碼中的潛在問題，例如內存洩漏、不必要的佈局等，從而提高應用程序的性能和可維護性。

8. 使用 Profiler 工具：使用 Profiler 工具可以幫助開發者分析應用程序的性能瓶頸，從而優化應用程序的性能。

## android programming layout 跟 xml 效率與區別

Android 佈局可以使用編程方式實現，也可以使用 XML 文件實現。下面是 Android 編程方式佈局和 XML 佈局之間的效率和區別。

效率：

編程方式佈局的效率比 XML 佈局低，因為編程方式佈局需要編寫更多的代碼，而且需要手動設置佈局參數、尺寸等屬性。相比之下，使用 XML 佈局可以更快速地實現 UI 佈局，因為開發者只需要在 XML 文件中定義佈局結構和屬性，就可以完成佈局的設計。此外，使用 XML 佈局還可以使用 Android Studio 的可視化佈局編輯器，更加快捷地進行佈局設計。

區別：

1. 可讀性：XML 佈局文件具有良好的可讀性，可以更加直觀地表現出佈局結構和屬性。而編程方式佈局的代碼可能較為冗長，可讀性較差。

2. 可維護性：XML 佈局文件可以更方便地進行佈局的修改和調整，而編程方式佈局則需要修改源代碼。因此，XML 佈局具有更好的可維護性。

3. 靈活性：編程方式佈局具有更大的靈活性，可以更好地應對一些複雜的佈局需求，而 XML 佈局則有一些佈局需求無法直接滿足，需要通過自定義控件或者使用編程方式佈局來實現。

總體而言，編程方式佈局更加靈活，但代碼量較多，可讀性和可維護性較差。使用 XML 佈局可以更快速地實現 UI 佈局，同時具有更好的可讀性和可維護性。根據實際需求，開發者可以選擇適合自己的佈局方式。

## view 繪製的過程， ondraw 調用的是 哪個 ondraw

在 Android 中，每個 View 都有一個 onDraw() 方法，用於繪製該 View 的內容。onDraw() 方法是一個回調方法，當 View 需要繪製自身時會自動調用。

在繪製過程中，onDraw() 方法通常是由 ViewRootImpl 類的 performTraversals() 方法調用的。performTraversals() 方法是 View 的測量、佈局和繪製過程中的核心方法，負責執行測量、佈局和繪製流程，並觸發相應的回調方法，其中就包括 onDraw() 方法。

具體來說，performTraversals() 方法會先調用 measure() 方法進行 View 的測量，然後調用 layout() 方法進行佈局，最後調用 draw() 方法進行繪製。在 draw() 方法中，會調用 View 的 dispatchDraw() 方法，該方法又會調用 onDraw() 方法，進行實際的繪製操作。

因此，在 View 的繪製過程中，實際調用的 onDraw() 方法是由 View 的 dispatchDraw() 方法調用的。如果我們想在 View 中實現自己的繪製邏輯，可以重寫 onDraw() 方法，並在其中編寫自己的繪製代碼。

## handler 消息機制原理跟不同線程間handler如何溝通

在 Android 中，Handler 消息機制是用來在不同的線程之間傳遞消息的機制。一個 Handler 對象可以被關聯到一個特定的線程，並且它可以接收和處理該線程發送的消息。

消息機制的核心是 MessageQueue 和 Looper。當一個 Handler 關聯到一個線程時，它會自動關聯到該線程的 Looper。當一個 Handler 接收到一個消息時，它會將該消息打包成一個 Message 對象，然後將其添加到關聯線程的 MessageQueue 隊列中。此時，如果該線程正在執行 Looper.loop()，它會從 MessageQueue 中取出 Message 對象並將其分發到對應的 Handler 進行處理。

不同線程間的 Handler 溝通可以通過兩種方式實現：

1. 使用 Handler 的 post() 或 postDelayed() 方法，這些方法可以將一個 Runnable 對象添加到該 Handler 所關聯的線程的 MessageQueue 隊列中。這樣就可以實現在不同線程中執行一段代碼的效果。

2. 使用 Handler 的 sendXXXMessage() 方法，這些方法可以將一個 Message 對象添加到該 Handler 所關聯的線程的 MessageQueue 隊列中。可以在 Message 中傳遞任何數據，這樣就可以實現在不同線程中傳遞消息的效果。

需要注意的是，如果要從一個子線程中發送消息到主線程中，可以使用主線程的 Looper 關聯的 Handler。如果要從主線程發送消息到子線程中，則需要在子線程中創建一個 Looper 和 Handler 對象，並且在子線程中執行 Looper.loop()，以讓子線程的消息隊列可以正常運行。

## 在Kotlin中，為什麼協程比線程要輕量？

在 Kotlin 中，協程是一種輕量級併發機制，與線程相比，協程具有以下幾個優勢：

1. 協程是用戶級別的，不需要啟動額外的操作系統線程，因此創建和銷毀協程的開銷很小，這使得協程比線程更輕量。

2. 協程可以在一個線程內運行多個協程，而不會阻塞線程。線程的創建和切換都需要消耗系統資源，而協程的切換不需要這些資源，因此協程比線程更輕量。

3. 協程使用了一種稱為「掛起」的機制來暫停和恢復執行，這種機制比線程的阻塞和喚醒機制更加高效。在協程中，當一個協程遇到一個掛起點時，它會暫停執行並釋放線程，直到掛起點完成後才會恢復執行。這使得協程比線程更加靈活和高效。

4. 協程提供了豐富的調度器和上下文機制，可以方便地控制協程的執行方式和環境。這些機制可以讓開發者更加方便地實現併發程式設計，而無需擔心線程的上下文切換和併發安全問題。

總之，協程比線程更輕量、更高效、更靈活，可以更好地滿足現代應用程式對併發性的需求。

## 可以解釋一下leakcanary 的原理嗎？

LeakCanary是一個針對Android應用程式記憶體洩漏檢測的工具庫，其原理可以概括為以下幾個步驟：

1. 在應用程式啟動時，LeakCanary會在後台啟動一個Service，該Service會監聽應用程式的記憶體分配情況，如果檢測到記憶體佔用量增加，並且某個物件被分配了一段時間（預設5秒鐘）但仍未被釋放，則LeakCanary將這個物件標記為“疑似洩漏物件”。

2. 一旦發現「疑似洩露物件」 LeakCanary 會在另一個進程中啟動一個Heap Dump工具，並在該工具中使用Android原生的hprof檔案格式將應用程式當前記憶體狀態進行快照（dump），並保存到本地存儲中。

3. LeakCanary會分析保存在本地的hprof文件，通過分析該檔中的物件引用關係，找出導致記憶體洩漏的物件及其引用鏈。

4. 最後，LeakCanary會將分析結果通過通知列提示、Log輸出等方式，提供給開發者進行分析和修復。

總的來說，LeakCanary通過監聽應用程式記憶體分配情況，快照應用程式記憶體狀態，分析物件引用關係等手段，來幫助開發者及時發現並修復應用程式中的記憶體洩漏問題。

### 能夠解釋一下Retrofit的源碼的工作原理嗎？

Retrofit是一個基於OkHttp網路庫的RESTful API請求框架，其原始程式碼的工作原理可以分為以下幾個方面：

1. 創建Retrofit實例。在創建Retrofit實例時，需要配置OkHttpClient對象、請求的基礎URL、轉換器工廠（Converter.Factory）等，這些配置資訊將被保存在Retrofit物件中，並用於後續的API請求。

2. 創建API介面。在Retrofit中，API介面是一個Java介面，其中定義了RESTful API的請求方法、請求參數、請求返回值等。Retrofit會根據介面中定義的請求方法生成一個動態代理類，通過該類實現API請求。

3. 發送API請求。在使用Retrofit發送API請求時，首先需要通過Retrofit.create（）方法創建API介面的代理物件，然後調用該代理物件中定義的請求方法，Retrofit會根據該請求方法的註解資訊（如@GET、@POST、@Query等）構建一個HTTP請求，使用OkHttpClient發送請求，並將響應結果轉換成Java物件返回。

4. 解析 HTTP回應。Retrofit使用轉換器工廠（Converter.Factory）將HTTP回應的結果轉換成Java對象，轉換過程可以通過自定義轉換器來擴展Retrofit的功能。

總的來說，Retrofit的原始程式碼實現了以下功能：

1. 封裝了OkHttp庫，使得API請求更加簡潔和易用。

2. 通過動態代理和註解等方式，簡化了API請求的代碼編寫。

3. 支援多種數據格式的解析，可以自定義轉換器擴展轉換功能。

4. 支援異步請求和同步請求，並提供了Callback和RxJava等方式處理異步請求結果。

## Android 如何實現類似微信小程式的功能？

要實現類似微信小程式的功能，需要使用 Android 的 WebView 元件來載入網頁，同時也需要與後端介面進行交互。

以下是一個基本的實現過程：

1. 首先，需要在 Android 應用中創建一個 WebView 元件，並設置其屬性，例如啟用 JavaScript

2. 接著，需要通過 WebView 元件的 loadUrl（） 方法載入小程式網頁。

3. 在網頁載入完成後，需要監聽 WebView 的 onPageDone（） 方法，獲取網頁中的內容，並根據需要調用 Android 應用中的方法進行處理。

4. 在小程式中需要調用後埠的情況下，可以使用Android應用中的 Retrofit 或 Volley 等網路庫來發送網路請求，獲取數據並顯示在小程式中。

5. 如果需要在小程式中使用 Android 應用的硬體功能（例如相機、感測器等），可以通過 JavaScriptInterface 來實現。

6. 在小程式中使用本地數據存儲時，可以使用 Android 應用中的 SharedPreferences 或 SQLite 資料庫等本地存儲方式。

需要注意的是，在實現小程式功能時，需要注意安全性和性能問題，例如網路請求的加密、數據傳輸的壓縮和緩存、圖片和資源的優化等。

## Kotlin 中 lambda的invoke是什麼？

在 Kotlin 中，Lambda 運算式本質上是一段可以作為參數傳遞的代碼塊。當我們將 Lambda 表達式傳遞給某個函數或方法時，實際上就是將這段代碼塊作為一個對象傳遞給了函數或方法。

`invoke`方法是 Lambda 運算式的主要執行方法，它接收與 Lambda 運算式參數類型相匹配的參數，然後執行 Lambda 運算式中的代碼，並返回執行結果。在 Kotlin 中，Lambda 表達式的`invoke`方法可以省略不寫，編譯器會自動將 Lambda 表達式轉換為對`invoke`方法的調用。因此，在實際程式設計中，我們通常會省略`invoke`方法的調用，直接使用 Lambda 運算式即可。

## android的 ViewModel的出現是為了解決什麼問題？ 並簡要說說它的內部原理？

Android中的ViewModel是為了解決配置更改（如設備旋轉）等情況下，Activity和Fragment中數據保存和管理的問題而引入的。在這些情況下，Activity或Fragment可能會被銷毀並重新創建，如果不使用ViewModel來保存和管理數據，則可能會導致數據的丟失或重複載入等問題。ViewModel是一個可觀察的類，它可以存儲和管理與UI相關的數據，並在配置更改時保持數據的一致性。ViewModel與Activity或Fragment的生命周期相關聯，因此ViewModel中的數據在配置更改后仍然存在。

ViewModel的內部原理主要包括以下幾個方面：

1. ViewModel使用LiveData來保存和管理數據，LiveData是一個可觀察的數據持有者，可以在數據發生變化時通知UI層。

2. ViewModel是與Activity或Fragment的生命週期相關聯的，當Activity或Fragment被銷毀時，ViewModel會被保存在後台，並在新的Activity或Fragment實例被創建時重用。

3. ViewModel可以通過Android的ViewModelProvider來獲取，每個Activity或Fragment都有一個對應的ViewModelProvider，可以通過ViewModelProvider來獲取該Activity或Fragment對應的ViewModel實例。

4. ViewModel可以與其他元件（如Repository）進行交互，以便在ViewModel中實現業務邏輯和數據處理。這樣可以將數據處理和業務邏輯分離，使得代碼更加清晰和易於維護。

## OOM到底是如何產生的呢？

OOM（Out of Memory）是指應用程式在運行時申請的記憶體超出了可用記憶體的限制，從而導致記憶體耗盡，無法再進行記憶體分配，最終導致程序崩潰或者被殺死。

OOM 錯誤主要是由以下原因引起的：

1. 記憶體洩漏

記憶體洩漏是指在應用程式中存在物件的引用未被及時清除，導致這些物件的記憶體空間一直被佔用而無法回收，最終導致記憶體耗盡，從而引發 OOM 錯誤。

2. 頻繁的記憶體分配和回收

頻繁的記憶體分配和回收會產生大量的記憶體碎片，從而導致無法分配出足夠大的連續記憶體空間，最終導致 OOM 錯誤。例如，在迴圈中頻繁地創建物件，或者使用大量的 Bitmap 物件等，都可能導致頻繁的記憶體分配和回收，從而引發 OOM 錯誤。

3. 記憶體抖動

記憶體抖動是指頻繁地進行大量的記憶體分配和回收操作，導致記憶體分配的堆空間不斷被佔用和釋放，從而產生不穩定的記憶體使用方式，最終導致 OOM 錯誤。

4. 記憶體使用不當

應用程式在使用記憶體時，如果沒有妥善地管理記憶體，可能會導致記憶體使用不當，從而導致 OOM 錯誤。例如，在使用大量 Bitmap 物件時沒有及時回收，或者使用大量的靜態變數等，都可能導致記憶體使用不當，從而引發 OOM 錯誤。

綜上所述，OOM 錯誤主要是由記憶體洩漏、頻繁的記憶體分配和回收、記憶體抖動以及記憶體使用不當等原因引起的。為避免 OOM 錯誤，我們應該盡量減少對象的創建和銷毀，盡量複用物件，使用物件池等技術，從而避免頻繁的記憶體分配和回收，提高應用程式的性能和穩定性。

## 請詳解Android事件傳遞流程

Android事件傳遞是指在Android應用程序中，當用戶與屏幕進行交互時，事件是如何被捕獲、分發和處理的。這個過程涉及到多個組件和機制，下面是事件傳遞的詳細流程：

1. 用戶發起一個事件，例如點擊屏幕、滑動屏幕等。
2. 事件首先被傳遞給Activity的Window（窗口）管理員，即WindowManager。
3. WindowManager將事件傳遞給應用程序的最上層的Window，即當前處於前景的Activity所對應的Window。
4. 當前Window在其內部進行事件分發，它會首先將事件傳遞給佈局(Layout)層級的ViewGroup，即佈局文件中根佈局。
5. ViewGroup會在它自己和它的子View之間進行事件分發，首先詢問自己是否可以處理該事件，如果不能處理則將事件傳遞給它的子View。
6. 如果該View也無法處理該事件，該事件會被傳遞到它的父ViewGroup中，直到被某個View或ViewGroup處理。
7. 如果在ViewGroup及其所有的子View中都找不到可以處理該事件的View，事件就會傳遞給當前Activity所對應的上一級Activity的Window進行分發，繼續進行事件的傳遞與分發。
8. 如果最終都沒有處理該事件的View，該事件就會被丟棄。

簡單地說，事件從WindowManager開始進行傳遞，然後傳遞給當前Activity的最上層Window，接著傳遞給佈局文件中的ViewGroup及其子View，最終可能會被傳遞到當前Activity的上一級Activity。在整個過程中，事件的傳遞方向是自下而上的，即從子View到父View，直到事件被處理或者被丟棄。

## 請解釋一下 Glide 三級緩存？

Glide的三級緩存包括弱引用緩存，內存緩存LruCache和磁盤緩存。當Glide請求一張圖片時，它首先會從弱引用緩存中獲取，如果沒有則從內存緩存LruCache中獲取，如果有磁盤緩存，接著去磁盤中獲取，最後才是通過網絡獲取。





## 對公司方的提問

1. 請問公司目前正在發展哪些產品或技術？我很感興趣並且想了解公司的未來發展方向，以及我是否有機會參與到未來的產品開發中。

2. 公司是否有哪些內部培訓計畫或晉升機會？我很關心在公司中的職業發展和成長的機會，這對我非常重要。

3. 請問在這個職位中最具挑戰性的部分是什麼？我想了解一下，這樣我就可以準備應對未來的挑戰，以及確定我是否有信心應對這些挑戰。

4. 能否分享一下公司的團隊組成？我想了解一下我是否與該團隊的成員相處融洽，以及是否能夠互相學習和協作。

5. 能否介紹一下該職位的日常工作內容？我想確定一下這個職位是否與我的興趣和專業相關，以及在工作中需要具備哪些技能和能力。

6. 是否有其他工程師可以指導我的工作？我想了解一下公司是否有提供專業的導師和教育訓練，以便我能夠更好地學習和成長。

7. 公司的開發流程是怎樣的？我想了解一下公司的開發流程和工具，以便我能夠更好地適應公司的工作環境。

8. 請問公司對員工的評估方式是怎樣的？我很關心公司對員工的評估方式和評估標準，這對我在公司中的職業發展和成長非常重要。

9. 公司的團隊文化是怎樣的？我想了解一下公司的團隊文化和氛圍，以便我能夠更好地適應團隊和工作環境。

10. 公司的招聘流程是怎樣的？我想了解一下公司的招聘流程和時間表，以便我能夠更好地安排我的時間和計劃。

11. 公司對員工的福利待遇是怎樣的？我很關心公司對員工的福利和待遇，這對我未來在公司的職業發展和生活品質有很大的影響。

12. 公司的管理風格是怎樣的？我想了解公司的管理風格和決策模式，以便我能夠更好地適應公司的文化和工作環境。

13. 公司使用的主要技術堆棧是什麼？我想了解公司使用的主要技術堆棧，以便我能夠更好地了解公司的技術環境和開發流程。

14. 公司是否有一個完善的代碼審查過程？我很關心公司是否有一個完善的代碼審查過程，這對於開發團隊的工作質量和效率都有很大的影響。

15. 公司如何確保代碼質量和測試覆蓋率？我想了解公司如何確保代碼質量和測試覆蓋率，以便我能夠更好地了解公司的測試流程和品質保障機制。

16. 公司是否有一個開發環境的自動化配置和管理系統？我很關心公司是否有一個開發環境的自動化配置和管理系統，這對於開發團隊的效率和一致性都有很大的影響。

17. 公司有沒有采用持續集成/持續交付流程？如果有，那公司使用哪些工具和技術來實現？我想了解公司的開發流程，以便我能夠更好地了解公司的技術環境和開發效率。

18. 公司如何處理代碼庫和版本控制？我很關心公司如何處理代碼庫和版本控制，這對於開發團隊的協作和代碼管理都有很大的影響。
